# React Hooks

<https://reactjs.org/docs/hooks-reference.html>

`2021-02-06, react hook`

Hook: react function that lets you hook into react state and lifecycle features from inside a function component

Array destructuring allows us to give different names to the state variables when declaring useState one or more times. React assumes you will always call hooks in the same order, that's why you can call hooks multiple times with different variables.

## Hooks

- üìåState Hook, useState = add and manage local component state
  - You can use primitive values as the initial value, or arrays, or objects
  - Its recommended to simply split state into multiple useStates, and only use arrays or objects for variables that always change together
  - `setState` always replaces the whole state, it doesn't merge it, keep that in mind when you set and array or object as initial value
  - You can provide a variable as argument to `setState` like this: `setState(var)` and that will replace state
  - You can also provide a function to `setState`, that function will receive the previous state as argument, and anything returned from it will be the new state
    - This is useful when you have a calculation that depends on previous state, because `setState` is async and simply queueing multiple `setState` calls leads to react ignoring most of them since they are applying the same value
    - For example: with `const counter = 1`, sending `setState(counter + 1)` three times ends up with react seeing three `setState(1 + 1)`, that means it will apply the first and ignore the rest, ending up with `counter = 2`
    - Instead you should send three `setState(oldCounter => oldCounter + 1)`, that way react will execute the function three times, and you end up with `counter = 4`. Note that `oldCounter` can be anything, like `banana`, but `oldCounter` is more semantically correct.
- ‚ö°Ô∏èEffect Hook, useEffect = execute side-effects from inside a component after rendering the component, by default on every render, including the first render.
  - Side-effects can either require clean-up or not
    - Without clean-up, run and forget: Network requests, manual DOM mutations, logging
    - With clean-up, to avoid memory leaks: subscription to external data source or setInterval, you then declare a return function inside the effect, and react will use it to cleanup the side-effect
  - Can have an optional second argument, an array of one or more values to check, if no values changed, useEffect doesn't run on that re-render
    - If using this second argument, make sure to check all variables used by the effect that you might need to include
  - Try to declare functions used by useEffect _inside_ useEffect (using an anonymous arrow function), to easily see what variables useEffect is using
- üîåContext Hook, useContext = read and subscribe component to contexts
- üîåReducer Hook, useReducer = one source of truth for multiple States, dispatchers, actions (simplified Redux built-into react), used to manage complex local state
- useRef =
- üí° Custom hooks: always start with `use`, and are used to extract hook logic into its own function and reuse it in multiple components
  - So you can move the useState initialization, the handleChange functions, any useEffect initialization related, into its own custom `use` function, and then call that custom Hook from inside the original React function component
  - Each call to a custom Hook has a completely isolated state, so you can reuse the same custom Hook multiple times inside one React component

## Rules of Hooks

- Always call Hooks at top level, do not call them inside a conditions, loops, nested functions, etc.
  - This is because React relies on Hook order to maintain state, so hiding a Hook inside a condition can change the order and lead to bugs
- Always call Hooks from React function component, do not call them from regular javascript functions
  - The only exception is if you're making a custom Hook
